Il existe deux types de substitutions :

Les substitutions normales (différées) sont introduites par $.
Insertion d'un caractère : $<c> avec c le code caractère.
Insertion d'une expr./cmd : $[] avec l'expr. ou la commande
Insertion d'une variable : $() avec le nom de la var. (ou $v).

Liste des formes substituables :
  $<c>      Remplace c par le caractère correspondant, parmi :
            n:nouv ligne, t:tab, e:espace, g:", q:', Q:`, c:^, d:$,
            r:return, b:backspace, f:formfeed, i:!, l:cloche
            ou le code ascii décimal, ou une chaîne encadrée par ''.
            Pour une liste complète des codes de caractères, cf.
            http://www.asciitable.pro/ascii_table.htm
            ex. print $<n>$<t>$<l>
            Avec c*n : le caractère est répété n fois :
            ex. print |$<e*10>|    --> |          |
                print $<'salut'*3> --> salutsalutsalut
  $(x)      Résout la variable x.
            Les macros et alias sont aussi des variables. En tant
            que commande, utiliser le nom de la commande seul.
            Ex. def f {print ok}; f -- et non $(f)
            Si le nom de la var. est alphanumérique, on peut omettre
            les (), ex. print "2x=$[2 * $x]" -- $x pour $(x)
            Singularité : def a a; print $($($(a))) --> a
  $[expr]   Évalue l'expression expr (expr est un code du SE)
            Utilisée comme une COMMANDE, le $[] est omissible
            Pour le SE js taper HELP JS-FUNCT pour plus d'information
  $[cmd]    Évalue la commande cmd, pour être embarquée dans une autre.
            Peut être une commande SQL ou interne. La valeur de retour
            de la commande est retournée pour être substituée et
            affectée à _RET_VALUE.
            Ex. print $[call 4*5] $[select toto from matable]
            Avec :END_CMD_NL à 0, nécessite de finir par un ';'.
            $[] retourne la dernière valeur évaluée.
  $`prompt` Demande en console 'prompt' et substitue la saisie.
            Si 'prompt' commence par '?', l'invite est améliorée,
            ou par '*', les caractères saisis sont affichés en '*'.
            Si plusieurs 'prompt' identiques sont à substituer, un
            seul est demandé. Ex. print $`?n`+$`n`
            Par contre les valeurs sont internes à un Lecteur :
            Ex. print $`?n`+$`n`=$[$`?n`+$`n`] -- 2 demandes.
            Ici il est préférable d'utiliser des var. locales...
            Note : quelque soit la saisie, le contenu ne sera pas
            substitué (ni exécuté). Substitution non imbricable.
            Ex: $`?val` (amélioré), $`?*val` (amélioré + MDP)

  Notes :
     - Les substitutions par $ sont faites une seule fois, même si la
       chaîne retournée contient elle-même des formes substituables.
     - Les substitutions $ sont échappables par '^', ex. ^$(x),
       et en chaîne dure, la substitution n'est pas réalisée.
     - Commande précédente : $(1), $(2)... sont les arguments,
       $(_l) la liste et $(_n) le nombre. Ex: void foo; print $1
       Fonctionne aussi en 1re commande de script.
       Attention : la commande précédente peut être interne !
          Ex: if 1 {print $0} --> if car c'est la dernière commande
              put 1 2 3; print $0 --> put
       Pour les arguments d'une commande, préférer $(arg1), $(arg_ls)
     - Caractères spéciaux autorisés en nom de variable : .-_
     - Quand la variable n'existe pas, une erreur est levée, sauf
       si le nom de variable est préfixé par '*', exemple : $(*x)
     - Il est possible de retourner une valeur en cas de variable
       non définie par '?'. Ne pas utiliser de modificateurs.
       ex. print $(*x?ND) -- * pour éviter l'erreur
     - Ne concerne que les variables internes appelables par $(),
       et non celles appartenant au SE (ex. js) appelables par $[]
     - Il peut être nécessaire d'encadrer la substitution par "", en
       particulier si le modificateur sépare l'argument.
       Ex. "$(a= )", "$(x%*2 + 1)", "$(x/\d{2})"
     - '$' ou '$$' seul en argument n'est pas substitué
     - Un [ ou ] seul dans $[] doit être échappé par deux ^

  Modificateurs pour substitution de variable $() :
     - égalité (=) : $(x=foo)
     - inégalité (~) : $(x~foo)
     - valeur par défaut si non définition (?) : $(x?foo)
     - valeur définie en lecteur père au niveau n : $(x\n)
       Ne s'applique qu'aux variables locales, mais si n='g' ou si
       pas de locale n trouvée, force la recherche en globale.
     - recherche de clef en dictionnaire (,) : $(x,k)
     - arithmétique (%) : $(x%*2+1) $(x%<2) $(x%==2*5)
     - commandes (#) : len : longueur (str), size* : taille (list),
         inc! : incrémentation (int), dec! : décrémentation (int),
         empty? : test vide (str), next : incrémentation (str),
         shift* : décalage (list), shift!* : idem avec retour du 1er,
         pop!* : retour du dernier (list), index|s| : index de s
         (str), lstindex|s|* : dernier index de s (str), eval :
          évaluation, sub : substitution par $
       *  : s'appliquent à une liste (sép. : espace, tab, ligne ;
            et encadreurs : rien, []).
         Note : les séparateurs ne peuvent pas être échappés et sont
         tous (saut de ligne, tab...) remplacés par ' '
       Les commandes terminant par ! modifient la variable.
       |s| : les param. éventuels se déclarent entre | et | séparés
           par des virgules (échappées par '^' au besoin).
           Ex. print $(str#len) $(list#size) $(list#has?|abc|)
               def x a ^"b c^"; $(x#size) --> 2
     - substitution de chaîne (:) : $(x:reg1=rep1,reg2=rep2...)
     - extraction de sous-liste (@) : $(x@2) ou $(x@3:) ou $(x@2:4)
       La liste peut être encadrée par "" ou {}
     - extraction de sous-chaîne (&) : $(x&1,2-3)
     - comparaison avec regexp (/) : $(x/[A-Za-z_]) (ret. 0|1)
     '!' juste après le caractère de modification modifie la variable
      ex. $(x%!+1)   -- incrémente x de 1, comme $(x#inc!)
          $(*x?!foo) -- affectation in situ
      Note : s'il y a un espace ou un car. spécial (ex. {}) dans la
      chaîne, il faut encadrer la var. de ""

Les substitutions par $ sont groupées en un seul argument.
Il peut arriver qu'il faille pourtant "dégrouper" l'argument. Pour
cela préfixer l'argument par # (échappable par ^), ou bien utiliser
la substitution par liste (précoce par § si :LIST_SUBSTIT à 1).
Exemples :
  def nbargs { print $(arg_nb) } -- nombre d'arguments
  nbargs "do ré mi"   --> 1
  nbargs "#do ré mi"  --> 3
  nbargs "^#do ré mi"  --> 1, car # est ici échappé
  def f { return do ré mi }
  nbargs $[f]  --> 1
  nbargs #$[f]  --> 3
  opt :LIST_SUBSTIT 1; nbargs §[f]  --> 3
Note : on ne peut avoir nbargs = 0 dès lors que l'on passe un
       argument, même avec #
Exemple :
  def f {put}
  nbargs $[f]  --> 1 et non 0
  nbargs #$[f] --> idem

Les substitutions par listes (précoces) sont introduites par §.
Positionner :LIST_SUBSTIT à 1 pour les activer.
Elles sont utilisables sur le même modèle que $ (excepté l'absence de
support des substitutions directes ex. §x). La différence importante
est que la substitution est précoce, *avant* l'analyse du code et donc
le groupage des arguments. C'est une sorte de pré-processeur.
Exemple d'application :
  def l do ré mi
  def nbargs { print $arg_nb }
  nbargs $l   --> 1
  nbargs §(l) --> 3 : passage par liste
Autre exemple tordu :
  def c "/*"; print §(c) commentaire pas affiché */
Notes :
    - le texte en commentaire, ainsi que les chaînes dures sont
      aussi concernés par cette substitution précoce !
    - les structures suivantes ne fonctionnent donc pas car § est
      substitué de façon précoce (substitution avant éval. du bloc) :
      def a 123; print §(a)        -- une ligne en console = 1 bloc
      def f { a 123; print §(a) }  -- une macro = 1 bloc
