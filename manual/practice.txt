Il existe 6 types de commandes, dans l'odre de résolution :
  - les commandes SQL : interprétées par Lecteur uniquement pour les
    substitutions, chaînes "", elles sont évaluées par le SGBD.
    Ex : SELECT, UPDATE, COMMIT
  - les commandes internes : ce sont des fonctions compilées en Java,
    intégrées au fichier exécutable lunasql.jar, évaluées par LunaSQL
    Ex : PRINT, IMPORT, ARG
  - les greffons de commandes : comme les commandes internes, mais
    pas intégrées au fichier lunasql.jar
  - les macros : ce sont des fonctions interprétées en code LunaSQL,
    déclarées par DEF, supportant les arguments nommés
    Ex. defmacro, loaded
  - les alias : comme les macros, mais ne supportant pas les
    arguments nommés, ils fonctionnent comme des "raccourcis", si
    l'option :ALIAS_ARG est à 0 ou si son nom est préfixé par ':'
    Ex : defm
  - les expressions du ScriptEngine : comme les commandes SQL,
    interprétées par Lecteur pour les substitutions, chaînes "", elles
    sont envoyées au moteur ScriptEngine (SE) courant (défaut : js).

Les requêtes SQL et commandes se tapent au prompt 'SQL>'.
Les commandes peuvent être appelées par leur raccourci (ex. PRINT : <).
Une bonne pratique est de réserver les raccourcis de commandes pour la
frappe en console, et préférer les noms complets dans les scripts et
macros ou alias.

Commentaire simple-ligne préfixé par '--' et multi-ligne encadré par
/* */ ex. /* commentaire */. Commentaire actif introduit par --~ ou
tout ce qui suit -~ dans un commentaire simple ligne --.
Note : les démiliteurs /* et */ sont reconnus par modèle :
   /* */ /**/ /*/ sont trois commentaires valides, mais
   select /*comment*/* from test;  -- n'est pas valide
   select /*comment*/ * from test; -- mieux
Ex :  /* commentaire multi-ligne, pas imbricable */
      -- commentaire simple-ligne normal
      --~ commentaire pour SGBD, pas pour LunaSQL
      -- commentaire -~ mais ceci est exécuté en LunaSQL
      --~ print exon1 -- intron1 --~ exon2 -- intron2
      -- si LunaSQL -~ opt :END_CMD_NL 0 -- en script SGBD

Le caractère '^' permet d'échapper les caractères spéciaux suivants :
'$' (substitution), fin de ligne, apostrophe, guillemets et ';'.
Note: ^ ne s'échappe pas lui-même.

Exécution de script (SQL, ScriptEngine) également possible en console.
Exemples :
  SQL> print "un texte simple";   -- commande LunaSQL
  SQL> select * from ma_table;    -- requête SQL au SGBD
  SQL> import contenu.csv;        -- commande LunaSQL
  SQL> 6*Math.PI;                 -- évaluation SE
  SQL> "function f(){...}";       -- déclaration SE js (notez les "")
  SQL> exec script.sql;           -- exécution d'un script en console

Selon la constante :END_CMD_NL, une commande peut se terminer par ';'.
Cela est utile pour longue commande : positionner :END_CMD_NL à 0
de façon à les devoir valider par un ';' (et non une fin de ligne).
Note : en console, si :END_CMD_NL est à 0, les commandes *doivent*
se terminer par ';'. En lecteur fils (script, sous commande...), le
';' n'est qu'un *séparateur* de commandes : il n'est pas requis en
fin de commande.
Ex. SQL> opt :END_CMD_NL 0          -- passage en terminateur ';'
    SQL> print $[str len hello];    -- pas de ';' en commande STR

Les parenthèses, guillemets simples et doubles forcent une nouvelle
ligne en cas de caractère de fin de ligne. Les guillemets doubles sont
supprimés après interprétation.
Les commandes peuvent accepter des options, commençant par un tiret.
Ex. SQL> print -c=3 "de la couleur!"; -- écrit ce texte en jaune
Pour passer à la commande du texte commençant par '-' qui n'est pas
une option, précéder les arguments à échapper par "--" (avec les ").
Ex. SQL> print "--" -ceci -est -un -texte -avec -tirets;

--- Blocs de code et chaînes de caractères longues ---
Ils peuvent se déclarer de plusieurs façons :
- Chaînes dures
Les chaînes encadrées par { et } ou $$ et $$ sont dites "dures",
c'est-à-dire que rien n'est échappé ni substitué, mais les {} en début
et fin de chaîne sont supprimés. Les délimiteurs $$ sont conservés
(compatibilité avec délimiteurs H2). Pour délimiter des blocs de code,
utiliser {}, qui interdisent également les substitutions.
{} sont recommandés pour DEF, IF, FOR, WHILE et CASE car elles peuvent
être imbriquées et différent les substitutions.
Les $$...$$ ne peuvent pas être imbriqués, et $$$$ est invalide
(il faut insérer au moins un caractère (ex $$ $$) ou bien placer
le triplet $$$ ($$a$$$b$$ -> $$a$$ $$b$$).
 ex. if [ 2>1 ] { print ok; print $(x) } -- $(x) est différé
- Chaînes douces
Les chaînes douces (ou normales) sont encadrées par "", '', [] ou ``.
Elles sont substituées mais échappent les caractères hors $ : "";...
Pour délimiter un bloc de code, seuls "" sont autorisés.
 ex. if [ 2>1 ] "print ok; print ^$(x)" -- protéger $(x)
Il peut donc être nécessaire d'échapper les $, mais pas les ;
En chaîne normale, un ^ en fin de ligne échappe le saut de ligne.
Le ^ peut aussi servir en blocs [] ou {}.
 ex. if $[str len ^^]] {print "^}"}
     -- notez en $[] les ^^ et en {} l'encadrement par "" + ^
Plus d'info : cf help substitutes
- Parenthèses ( et )
Un argument encadré par ( et ) sera nettoyé des commentaires,
coupé par les points-virgules et substitué avant exécution. Les ()
peuvent être imbriquées. Il n'est pas du tout protégé : les éléments
du bloc sont simplement des arguments de la commande principale.
Ne sont pas autorisées pour délimiter un bloc de code, une liste ou
un dictionnaire.
 ex. print ( foo^; bar ^$(x) ) -- protéger $(x) et ;
     print (;) -- invalide : échapper le ; !
     if 1 ( print ko! ) -- ne fonctionne pas !

Rapport entre chaînes, délimiteurs et interprétation :
  def c sub                     -- chaîne?  délim? interp?
  print "a /* comm */ b $(c)"   --  oui      non     oui
  print 'a /* comm */ b $(c)'   --  oui      oui     oui
  print (a /* comm */ b $(c))   --  non      -       oui
  print [a /* comm */ b $(c)]   --  oui      oui     oui
  print {a /* comm */ b $(c)}   --  oui      non     non
  print <a /* comm */ b $(c)>   --  non      -       oui
  print `a /* comm */ b $(c)`   --  oui      oui     oui
  print $$a /* comm */ b $(c)$$ --  oui      oui     non
L'interprétation comprend les substitutions et échappements
(ex. les ^ de caractères ou fin de lignes).

Groupage des arguments en fonction des délimiteurs :
  def nbargs { print $(arg_nb) } -- nombre d'arguments
  nbargs a"b""c"d     --> 4
  nbargs a$$b$$ $$c$$d  --> 4
  nbargs a$$b$$$c$$d  --> 4 (notez les $$$ pour $$ $$)
  -- en effet "" et $$ $$ séparent les arguments
  nbargs a(b)(c)d     --> 1
  nbargs a[b][c]d     --> 1
  nbargs a{b}{c}d     --> 4 car {} séparent les arguments
  nbargs a'b''c'd     --> 1
  nbargs a`b``c`d     --> 1

La séparation d'arguments par {} et "" permet en fait les structures
suivantes :
  print a"b"{c}d  --> a b c d
  print"ok"
  defmacro f"a b c"{print $a $b $c}" Aide de f..."

Les chaînes douces et dures délimitent donc les arguments. Pour le
groupage des arguments substitués, cf. l'aide "substitutes".
